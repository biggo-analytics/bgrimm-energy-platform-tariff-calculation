/**\n * Enhanced Base Electricity Controller\n * \n * Refactored controller that applies SOLID principles and eliminates DRY violations.\n * Uses composition and dependency injection for better modularity and testability.\n * \n * SOLID Principles Applied:\n * - Single Responsibility: Controller only handles HTTP concerns\n * - Open/Closed: Easy to extend without modifying existing code\n * - Liskov Substitution: All services implement the same interface\n * - Interface Segregation: Focused interfaces for specific responsibilities\n * - Dependency Inversion: Depends on abstractions, not concretions\n */\n\nconst { ValidationError, CalculationError, asyncErrorHandler } = require('../utils/error-handler');\nconst { logger } = require('../utils/logger');\n\n/**\n * Enhanced Base Controller for Electricity Calculations\n * \n * Provides common functionality for all electricity calculation controllers\n * using composition and dependency injection.\n */\nclass EnhancedBaseElectricityController {\n  constructor(electricityService, provider) {\n    this.electricityService = electricityService;\n    this.provider = provider;\n    \n    // Bind methods to maintain context\n    this.calculateType2 = this.calculateType2.bind(this);\n    this.calculateType3 = this.calculateType3.bind(this);\n    this.calculateType4 = this.calculateType4.bind(this);\n    this.calculateType5 = this.calculateType5.bind(this);\n    this.getCalculationInfo = this.getCalculationInfo.bind(this);\n    this.getValidationSchema = this.getValidationSchema.bind(this);\n    \n    this._validateConstructorParameters();\n  }\n  \n  // =========================================================================\n  // CALCULATION ENDPOINTS\n  // =========================================================================\n  \n  /**\n   * Calculate Type 2 (Small General Service) bill\n   * \n   * @param {Object} ctx - Koa context\n   * @returns {Promise<void>}\n   */\n  calculateType2(ctx) {\n    return this._handleCalculationRequest(ctx, 'type-2');\n  }\n  \n  /**\n   * Calculate Type 3 (Medium General Service) bill\n   * \n   * @param {Object} ctx - Koa context\n   * @returns {Promise<void>}\n   */\n  calculateType3(ctx) {\n    return this._handleCalculationRequest(ctx, 'type-3');\n  }\n  \n  /**\n   * Calculate Type 4 (Large General Service) bill\n   * \n   * @param {Object} ctx - Koa context\n   * @returns {Promise<void>}\n   */\n  calculateType4(ctx) {\n    return this._handleCalculationRequest(ctx, 'type-4');\n  }\n  \n  /**\n   * Calculate Type 5 (Specific Business Service) bill\n   * \n   * @param {Object} ctx - Koa context\n   * @returns {Promise<void>}\n   */\n  calculateType5(ctx) {\n    return this._handleCalculationRequest(ctx, 'type-5');\n  }\n  \n  // =========================================================================\n  // INFORMATION ENDPOINTS\n  // =========================================================================\n  \n  /**\n   * Get information about available calculations\n   * \n   * @param {Object} ctx - Koa context\n   * @returns {Promise<void>}\n   */\n  getCalculationInfo(ctx) {\n    return asyncErrorHandler(async () => {\n      try {\n        const availableCalculations = this.electricityService.getAvailableCalculationTypes();\n        \n        ctx.status = 200;\n        ctx.body = {\n          success: true,\n          provider: this.provider,\n          availableCalculations,\n          timestamp: new Date().toISOString(),\n          architecture: 'enhanced-modular'\n        };\n      } catch (error) {\n        logger.error('Failed to get calculation info', {\n          provider: this.provider,\n          error: error.message\n        });\n        \n        ctx.status = 500;\n        ctx.body = {\n          success: false,\n          error: 'Unable to retrieve calculation information',\n          provider: this.provider\n        };\n      }\n    })(ctx);\n  }\n  \n  /**\n   * Get validation schema for a calculation type\n   * \n   * @param {Object} ctx - Koa context\n   * @returns {Promise<void>}\n   */\n  getValidationSchema(ctx) {\n    return asyncErrorHandler(async () => {\n      const calculationType = ctx.params.calculationType;\n      \n      if (!calculationType) {\n        ctx.status = 400;\n        ctx.body = {\n          success: false,\n          error: 'Calculation type parameter is required',\n          provider: this.provider\n        };\n        return;\n      }\n      \n      try {\n        const schemaInfo = this.electricityService.getValidationSchema(calculationType);\n        \n        ctx.status = 200;\n        ctx.body = {\n          success: true,\n          provider: this.provider,\n          schemaInfo,\n          timestamp: new Date().toISOString()\n        };\n      } catch (error) {\n        ctx.status = 404;\n        ctx.body = {\n          success: false,\n          error: `No validation schema found for ${calculationType}`,\n          provider: this.provider\n        };\n      }\n    })(ctx);\n  }\n  \n  // =========================================================================\n  // PRIVATE METHODS\n  // =========================================================================\n  \n  /**\n   * Generic calculation request handler\n   * \n   * This method provides a template for all calculation requests,\n   * implementing the Template Method Pattern.\n   * \n   * @private\n   * @param {Object} ctx - Koa context\n   * @param {string} calculationType - Type of calculation\n   * @returns {Promise<void>}\n   */\n  _handleCalculationRequest(ctx, calculationType) {\n    return asyncErrorHandler(async () => {\n      const startTime = Date.now();\n      \n      try {\n        // Step 1: Extract and validate request data\n        const requestData = this._extractRequestData(ctx);\n        \n        // Step 2: Log calculation request\n        this._logCalculationRequest(calculationType, requestData);\n        \n        // Step 3: Perform calculation using enhanced service\n        const calculationResult = this.electricityService.calculateBill(\n          calculationType,\n          requestData\n        );\n        \n        // Step 4: Build and send successful response\n        const response = this._buildSuccessResponse(\n          calculationResult,\n          calculationType,\n          startTime\n        );\n        \n        ctx.status = 200;\n        ctx.body = response;\n        \n      } catch (error) {\n        // Step 5: Handle errors appropriately\n        this._handleRequestError(ctx, calculationType, error, startTime);\n      }\n    })(ctx);\n  }\n  \n  /**\n   * Extract and validate request data\n   * \n   * @private\n   * @param {Object} ctx - Koa context\n   * @returns {Object} - Validated request data\n   * @throws {ValidationError} - If request data is invalid\n   */\n  _extractRequestData(ctx) {\n    const requestBody = ctx.request.body;\n    \n    if (!requestBody || typeof requestBody !== 'object') {\n      throw new ValidationError(\n        'Request body is required and must be a valid JSON object',\n        'request_body'\n      );\n    }\n    \n    if (Object.keys(requestBody).length === 0) {\n      throw new ValidationError(\n        'Request body cannot be empty',\n        'request_body'\n      );\n    }\n    \n    return requestBody;\n  }\n  \n  /**\n   * Log calculation request\n   * \n   * @private\n   * @param {string} calculationType - Calculation type\n   * @param {Object} requestData - Request data\n   */\n  _logCalculationRequest(calculationType, requestData) {\n    logger.info('Enhanced calculation request received', {\n      provider: this.provider,\n      calculationType,\n      tariffType: requestData.tariffType,\n      voltageLevel: requestData.voltageLevel,\n      hasUsage: !!requestData.usage,\n      architecture: 'enhanced-modular'\n    });\n  }\n  \n  /**\n   * Build successful response\n   * \n   * @private\n   * @param {Object} result - Calculation result\n   * @param {string} calculationType - Calculation type\n   * @param {number} startTime - Request start time\n   * @returns {Object} - Response object\n   */\n  _buildSuccessResponse(result, calculationType, startTime) {\n    const processingTime = Date.now() - startTime;\n    \n    return {\n      // Spread calculation result\n      ...result,\n      \n      // Add metadata\n      success: true,\n      timestamp: new Date().toISOString(),\n      provider: this.provider,\n      calculationType,\n      \n      // Add performance metrics\n      metadata: {\n        processingTimeMs: processingTime,\n        architecture: 'enhanced-modular',\n        version: '2.1.0',\n        components: {\n          validation: 'composition-engine',\n          calculation: 'modular-factory',\n          formatting: 'standardized'\n        }\n      }\n    };\n  }\n  \n  /**\n   * Handle request errors\n   * \n   * @private\n   * @param {Object} ctx - Koa context\n   * @param {string} calculationType - Calculation type\n   * @param {Error} error - Error that occurred\n   * @param {number} startTime - Request start time\n   */\n  _handleRequestError(ctx, calculationType, error, startTime) {\n    const processingTime = Date.now() - startTime;\n    \n    // Log error with context\n    logger.error('Enhanced calculation request failed', {\n      provider: this.provider,\n      calculationType,\n      errorType: error.constructor.name,\n      errorMessage: error.message,\n      processingTimeMs: processingTime,\n      architecture: 'enhanced-modular'\n    });\n    \n    // Set appropriate HTTP status and response based on error type\n    if (error instanceof ValidationError) {\n      ctx.status = 400;\n      ctx.body = {\n        success: false,\n        error: error.message,\n        errorType: 'validation_error',\n        field: error.field,\n        provider: this.provider,\n        calculationType\n      };\n    } else if (error instanceof CalculationError) {\n      ctx.status = 422;\n      ctx.body = {\n        success: false,\n        error: error.message,\n        errorType: 'calculation_error',\n        provider: this.provider,\n        calculationType\n      };\n    } else {\n      // Generic server error\n      ctx.status = 500;\n      ctx.body = {\n        success: false,\n        error: 'An unexpected error occurred during calculation',\n        errorType: 'internal_server_error',\n        provider: this.provider,\n        calculationType\n      };\n    }\n    \n    // Add metadata to error response\n    ctx.body.metadata = {\n      processingTimeMs: processingTime,\n      timestamp: new Date().toISOString(),\n      architecture: 'enhanced-modular'\n    };\n  }\n  \n  /**\n   * Validate constructor parameters\n   * \n   * @private\n   * @throws {Error} - If parameters are invalid\n   */\n  _validateConstructorParameters() {\n    if (!this.electricityService) {\n      throw new Error('Electricity service is required');\n    }\n    \n    if (!this.provider) {\n      throw new Error('Provider is required');\n    }\n    \n    if (!['mea', 'pea'].includes(this.provider)) {\n      throw new Error('Provider must be either \"mea\" or \"pea\"');\n    }\n    \n    // Validate service interface\n    const requiredMethods = ['calculateBill', 'getAvailableCalculationTypes', 'getValidationSchema'];\n    for (const method of requiredMethods) {\n      if (typeof this.electricityService[method] !== 'function') {\n        throw new Error(`Electricity service must implement ${method} method`);\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  EnhancedBaseElectricityController\n};"
