/**
 * Enhanced Electricity Strategy Service
 * 
 * Refactored service that applies DRY and SOLID principles using the new modular components.
 * This service demonstrates how the new architecture eliminates code duplication and 
 * provides better separation of concerns.
 * 
 * SOLID Principles Applied:
 * - Single Responsibility: Service only orchestrates calculation and validation
 * - Open/Closed: Easy to extend with new calculation types
 * - Liskov Substitution: All calculators implement the same interface
 * - Interface Segregation: Focused interfaces for specific responsibilities
 * - Dependency Inversion: Depends on abstractions (factory, validation engine)
 */

const { calculatorFactory } = require('./billing/calculator-factory');\nconst { BillingValidationSchemas } = require('./validation/billing-validation-schemas');\nconst { ValidationError, CalculationError } = require('../utils/error-handler');\nconst { logger } = require('../utils/logger');\n\n/**\n * Enhanced Electricity Strategy Service\n * \n * Uses composition over inheritance and dependency injection to provide\n * flexible and maintainable billing calculations.\n */\nclass EnhancedElectricityStrategyService {\n  constructor(rates, serviceCharge = null, provider = 'mea') {\n    this.rates = rates;\n    this.serviceCharge = serviceCharge;\n    this.provider = provider;\n    \n    // Validate constructor parameters\n    this._validateConstructorParameters();\n  }\n  \n  /**\n   * Calculate electricity bill using modular components\n   * \n   * This method orchestrates the entire calculation process using\n   * the Factory Pattern and Template Method Pattern.\n   * \n   * @param {string} calculationType - Type of calculation (type-2, type-3, type-4, type-5)\n   * @param {Object} billingData - Input billing data\n   * @returns {Object} - Formatted calculation result\n   * @throws {ValidationError} - If input validation fails\n   * @throws {CalculationError} - If calculation fails\n   */\n  calculateBill(calculationType, billingData) {\n    try {\n      // Step 1: Validate input data\n      this._validateBillingData(calculationType, billingData);\n      \n      // Step 2: Get appropriate calculator\n      const calculator = this._getCalculator(calculationType, billingData.tariffType);\n      \n      // Step 3: Get applicable rates\n      const applicableRates = this._getApplicableRates(calculationType, billingData);\n      \n      // Step 4: Perform calculation\n      const result = calculator.calculateBill(billingData, applicableRates);\n      \n      // Step 5: Log successful calculation\n      this._logCalculationSuccess(calculationType, billingData, result);\n      \n      return result;\n      \n    } catch (error) {\n      this._handleCalculationError(calculationType, billingData, error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get information about available calculation types\n   * \n   * @returns {Array} - Array of supported calculation types with metadata\n   */\n  getAvailableCalculationTypes() {\n    return calculatorFactory.getSupportedCalculators().map(calc => {\n      return {\n        ...calc,\n        info: calculatorFactory.getCalculatorInfo(calc.customerType, calc.tariffType),\n        provider: this.provider\n      };\n    });\n  }\n  \n  /**\n   * Check if a calculation type is supported\n   * \n   * @param {string} calculationType - Calculation type to check\n   * @param {string} tariffType - Tariff type to check\n   * @returns {boolean} - True if supported\n   */\n  isCalculationSupported(calculationType, tariffType) {\n    return calculatorFactory.isSupported(calculationType, tariffType);\n  }\n  \n  /**\n   * Get validation schema for a calculation type\n   * \n   * @param {string} calculationType - Calculation type\n   * @returns {Object} - Validation schema information\n   */\n  getValidationSchema(calculationType) {\n    try {\n      const schema = BillingValidationSchemas.getSchemaForCalculationType(\n        calculationType, \n        this.provider\n      );\n      \n      return {\n        calculationType,\n        provider: this.provider,\n        hasSchema: true,\n        description: `Validation schema for ${calculationType} calculations`\n      };\n    } catch (error) {\n      return {\n        calculationType,\n        provider: this.provider,\n        hasSchema: false,\n        error: error.message\n      };\n    }\n  }\n  \n  // =========================================================================\n  // PRIVATE METHODS\n  // =========================================================================\n  \n  /**\n   * Validate constructor parameters\n   * \n   * @private\n   * @throws {Error} - If parameters are invalid\n   */\n  _validateConstructorParameters() {\n    if (!this.rates || typeof this.rates !== 'object') {\n      throw new Error('Rates configuration is required and must be an object');\n    }\n    \n    if (!['mea', 'pea'].includes(this.provider)) {\n      throw new Error('Provider must be either \"mea\" or \"pea\"');\n    }\n  }\n  \n  /**\n   * Validate billing data using validation engine\n   * \n   * @private\n   * @param {string} calculationType - Calculation type\n   * @param {Object} billingData - Billing data to validate\n   * @throws {ValidationError} - If validation fails\n   */\n  _validateBillingData(calculationType, billingData) {\n    try {\n      // Get validation schema for this calculation type\n      const validationSchema = BillingValidationSchemas.getSchemaForCalculationType(\n        calculationType, \n        this.provider\n      );\n      \n      // Perform validation with context\n      const validationResult = validationSchema.validate(billingData, {\n        calculationType,\n        provider: this.provider,\n        data: billingData\n      });\n      \n      // Throw detailed validation error if validation fails\n      if (!validationResult.isValid) {\n        const errorMessage = validationResult.errors.join('; ');\n        throw new ValidationError(\n          `Validation failed for ${calculationType} calculation: ${errorMessage}`,\n          'input_validation'\n        );\n      }\n      \n    } catch (error) {\n      if (error instanceof ValidationError) {\n        throw error;\n      }\n      \n      // Handle schema creation errors\n      throw new ValidationError(\n        `Unable to validate ${calculationType} data: ${error.message}`,\n        'validation_schema'\n      );\n    }\n  }\n  \n  /**\n   * Get appropriate calculator for calculation type and tariff type\n   * \n   * @private\n   * @param {string} calculationType - Calculation type\n   * @param {string} tariffType - Tariff type\n   * @returns {BillingCalculationEngine} - Calculator instance\n   * @throws {CalculationError} - If no suitable calculator is found\n   */\n  _getCalculator(calculationType, tariffType) {\n    try {\n      return calculatorFactory.createCalculator(calculationType, tariffType);\n    } catch (error) {\n      throw new CalculationError(\n        `No calculator available for ${calculationType} with ${tariffType} tariff: ${error.message}`,\n        'calculator_not_found'\n      );\n    }\n  }\n  \n  /**\n   * Get applicable rates for the calculation\n   * \n   * @private\n   * @param {string} calculationType - Calculation type\n   * @param {Object} billingData - Billing data\n   * @returns {Object} - Applicable rates configuration\n   * @throws {CalculationError} - If rates are not found\n   */\n  _getApplicableRates(calculationType, billingData) {\n    const { tariffType, voltageLevel } = billingData;\n    \n    try {\n      // Navigate to the specific rate configuration\n      const typeRates = this.rates[calculationType];\n      if (!typeRates) {\n        throw new Error(`No rates found for ${calculationType}`);\n      }\n      \n      const tariffRates = typeRates[tariffType];\n      if (!tariffRates) {\n        throw new Error(`No ${tariffType} rates found for ${calculationType}`);\n      }\n      \n      const voltageRates = tariffRates[voltageLevel];\n      if (!voltageRates) {\n        throw new Error(`No rates found for ${voltageLevel} voltage level`);\n      }\n      \n      // Add service charge if available\n      const applicableRates = {\n        ...voltageRates,\n        serviceCharge: voltageRates.serviceCharge || this.serviceCharge\n      };\n      \n      return applicableRates;\n      \n    } catch (error) {\n      throw new CalculationError(\n        `Unable to find applicable rates for ${calculationType} ${tariffType} at ${voltageLevel}: ${error.message}`,\n        'rates_not_found'\n      );\n    }\n  }\n  \n  /**\n   * Log successful calculation\n   * \n   * @private\n   * @param {string} calculationType - Calculation type\n   * @param {Object} billingData - Billing data\n   * @param {Object} result - Calculation result\n   */\n  _logCalculationSuccess(calculationType, billingData, result) {\n    logger.info('Enhanced calculation completed successfully', {\n      provider: this.provider,\n      calculationType,\n      tariffType: billingData.tariffType,\n      voltageLevel: billingData.voltageLevel,\n      resultComponents: Object.keys(result),\n      architecture: 'modular-enhanced'\n    });\n  }\n  \n  /**\n   * Handle calculation errors with appropriate logging\n   * \n   * @private\n   * @param {string} calculationType - Calculation type\n   * @param {Object} billingData - Billing data\n   * @param {Error} error - Error that occurred\n   */\n  _handleCalculationError(calculationType, billingData, error) {\n    logger.error('Enhanced calculation failed', {\n      provider: this.provider,\n      calculationType,\n      tariffType: billingData?.tariffType,\n      voltageLevel: billingData?.voltageLevel,\n      errorType: error.constructor.name,\n      errorMessage: error.message,\n      architecture: 'modular-enhanced'\n    });\n  }\n}\n\nmodule.exports = {\n  EnhancedElectricityStrategyService\n};"
